[{"title":"使用Rollup,TypeScript,SCSS配置React组件库","description":"想写一个React的组件库，但不知道该如何配置一个开发环境？这篇文章将告诉你答案","readNum":"249"},{"title":"使用puppeteer获取网页信息","description":"Puppeteer 是一个运行在Node端的浏览器，为我们提供了强大的功能，例如抓取页面数据，对页面进行截图等功能...","readNum":"1170"},{"title":"在函数组件中，如何实现shouldComponentUpdate()","description":"在函数组件中，我们该如何实现`class`组件才有的`shouldComponentUpdate()`生命周期的功能呢？","readNum":"631"},{"title":"更改MySQL的所有权限","description":"GRANT ALL PRIVILEGES ON db_name.* TO 'user_name'@'%' identified by 'password' ;FLUSH PRIVILEGES; ALL: 赋予所有权限db_name: 数据库名称user_name： 用户名%: 能操作数据库的IP，（%，指所有IP都能操作）password：用户密码...","readNum":"632"},{"title":"React之Context","description":"前言React为我们提供了Context用于将数据进行广播，消费者只需使用特定的方法就能拿到广播的数据，不用再采用层层递传props的方式。如果组件之间需要共享数据，也可以采用Context的方式，如react-router中的Router组件：...render() {    return (      <RouterContext.Provider  ..","readNum":"63"},{"title":"FormData多文件上传并同时添加其他数据","description":"前言在做项目时，有一个接口要求上传文件的同时能携带其它数据，在这里使用的是FormData对象来进行操作。简单介绍一下这个对象。FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 \"multipart/form-data\"，它会使用和表单一样的格式。(以上出自这里)单文件上传这里使用FormData的append()方法，该方法","readNum":"8097"},{"title":"git 用法","description":"前言别人上班，我摸鱼，别人加班，我摸鱼，然后就写出了这篇 Git 的简单使用教程。摸摸索索一个多月总算是完成了这篇 git 的学习笔记 ????， 还好最后还是坚持了下来，可能有些有问题，欢迎各位大佬指正。欢迎关注我的公众号, 微信搜索 「前端入坑手册」，大家一起学习呀????准备首先需要生成 ssh 秘钥，ssh-keygen -t rsa -C \"你公司内部邮箱地址\" ，如果成功，将会在~/.ssh文件夹下生成对应的私钥和公钥。ls复制id_rsa.pub文件的内容（如果是 Git","readNum":"122"},{"title":"eslint 搭配 vscode 的简单使用","description":"前言刚开始时，由于嫌麻烦，并没有安装eslint，最近在新的项目上使用了eslint再配合vscode的插件，真是爽的不要太爽。因此打算写一篇简单的食用说明来记录食用过程前期准备没啥好准备的，作为开发肯定是具备yarn和node的，编辑器使用的是微软的亲儿子vscode然后新建一个文件夹eslint-example，cd进入这个文件夹并初始化一个package.json初始化package.json命令$ yarn init -y文件结构- eslint-example - packag","readNum":"2959"},{"title":"使用canal连接kafka","description":"这篇主要是项目还原，目的是记录构建时遇到的各种奇葩坑，避免下次迷路。废话不多说，直接上手。默认已安装docker，docker-compose，nodejs，yarn，typescript首先根据 kafka-docker 这个官方的仓库下的docker-compose.yml复制一份到自己的项目中version: '2'services: zookeeper: image: wurstmeister/zookeeper ports: - \"2181:2181","readNum":"1107"},{"title":"this绑定规则","description":"确定一个this具体引用的是谁首先查看是否使用new操作符调用，使用new操作符后，this绑定到这个新创建的对象实例上 。const bar = new fn()是否使用call， apply，bind，使用了这三个方法后，会将this显示绑定（硬绑定）到传入的第一个参数const bar = fn.call(obj)是否通过一个对象上下文来引用函数，如果是，则会将this隐式绑定到这个对象const bar = obj.fn()如果都不是，则使用默认绑定，绑定到win","readNum":"24"},{"title":"kafka 报错 no leader","description":"作为Producer向kafka发送消息时，报出错误There is no leader for this topic-partition as we are in the middle of a leadership election具体的原因不是很清楚，但找到了解决方式 issue ，根据这个issue下面的回答，做了一下修改：删除了原来的KAFKA_BROKER_ID: 1添加了KAFKA_AUTO_CREATE_TOPICS_ENABLE: true在启动docker-compose时","readNum":"1833"},{"title":"创建对象和继承","description":"通常我们都习惯性使用对象字面量的形式创建一个新对象。该对象是Object的实例。而如果想要创建其他类型的对象，可以自定义构造函数，再实例化对象。这里不讲解class方式创建的对象创建对象我们将会讲解几种不同方式来创建对象工厂模式function createObject() { const o = new Object() o.name = 'yan' o.age = 18 o.sayName = function () { return this.n","readNum":"82"},{"title":"Map和WeakMap","description":"Map和Set是ECMAScript6新添加的集合引用类型。MapMap可以用于存储键值对的数据。在ECMAScript6之前为了达到这种效果都是使用的Object对象。基本API可以通过new关键字和Map构造函数创建一个空的映射const stringKey = 'key1'const numberKey = 1const symbolKey = Symbol('key')//创建一个空的映射const map = new Map()//使用.size属性查看长度console.l","readNum":"47"},{"title":"集合引用类型篇（二）","description":"定型数组//创建一个12字节的缓冲const buf = new ArrayBuffer(12)//创建一个引用buf缓冲的Int32Arrayconst ints = new Int32Array(buf)console.log(ints) //Int32Array(3) [0, 0, 0]//length属性，打印长度console.log(ints.length) //3//与DataView一样，也有一个指向关联缓冲的引用console.log(ints.buffer) //Arr","readNum":"85"},{"title":"集合引用类型篇（一）","description":"Object显示创建Object的实例对象有两种方法，一种是new Object()来实例化一个对象，另一种是使用对象字面量形式在使用对象字面量表示法定义对象时，其实并没有调用Object()构造函数Array有几种方式可以创建数组，一种是数组字面量，一种是通过new关键字调用但不传递参数或者传递参数，也可以直接使用Array()创建，在ES6中新增了两个静态方法创建数组：Array.from和Array.oflet a = []let a1 = [1, 2,]let a2 = [, 1,","readNum":"184"},{"title":"原始值包装类型","description":"原始值包装类型ECMAScript提供了3种特殊的引用类型：Boolean, Number, String 。这些类型具有其他引用类型一样的特点，但也具有与各自原始值类型对应的特殊行为。Symbol虽然也是函数，但由于其不存在constructor，所以不能通过new操作符实例化对象。前言每当用到某个原始值的方法或属性时，其后台都会为这个原始值创建一个包装对象，从而暴露相应的属性和方法。let str = 'name'let s2 = str.sustring(1) 原始值不是对象，但是却能使","readNum":"88"},{"title":"原始值和引用值","description":"ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值就是简单数据类型，引用值则是由多个值构成的对象原始值，引用值原始值包括：Undefined，Null，Boolean，Number，String，Symbol和BigInt (ES2020)引用值是保存在内存中的对象，即对象保存在堆中用来保存对象的变量其实只是保存了一个对象的引用，即地址对于原始值Boolean，Number和String都自带有一个包装对象let bool1 = truelet bool2 = n","readNum":"125"},{"title":"操作符篇（二）","description":"指数操作符ECMAScript 2017新增，使用两个**表示，相当于使用Math.pow()加性操作符即加法和减法操作符加法操作符如果有任一操作数是 NaN，则返回 NaN;如果是 Infinity 加 Infinity，则返回 Infinity;如果是-Infinity 加-Infinity，则返回-Infinity;如果是 Infinity 加-Infinity，则返回 NaN;如果是+0 加+0，则返回+0;如果是-0 加+0，则返回+0;如果是-0 加-0，则返回-0。不","readNum":"50"},{"title":"操作符篇（一）","description":"ECMAScript中的操作符是独特的，因为他们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。一元操作符只操作一个值的操作符叫一元操作符。递增递减操作符递增递减操作符非常方便，但也有很大的误区let age = 12console.log(++age) //13 //前缀递增操作符console.log(--age) //12 //前缀递减操作符console.log(age++) //会打印什么？13？ 不对，还是12console.log(age) //13 没错，后缀++会","readNum":"32"},{"title":"数据类型篇（三）","description":"Symbol 类型Symbol（符号）是ES6新增的数据类型。Symbol是原始值，且实例是唯一的，不可变的Symbol的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险Symbol使用Symbol()函数进行初始化let sym = Symbol()typeof sym // symbol let sym1 = Symbol('symbol')let sym2 = Symbol('symbol')console.log(sym1 == sym2) //falseSymbol(","readNum":"42"}]